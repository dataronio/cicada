* jojo
- [adventure.untyped] add string_t
- [adventure.untyped] add car cdr cons to
- [adventure.simple]
- [adventure.untyped_minimal] equivalent_val
- `assert_eq` for testing
- [adventure.dependent]
- encoding like lambda calculus
- how to implement call-by-name jojo calculus ?
- how to implement call-by-need jojo calculus ?
- what are continuation and cps in jojo calculus ?
- how to encode lambda calculus by jojo calculus ?
- how to encode pure type system by jojo calculus ?
- how to eval jojo with neutral ?
- how to handle local variable when eval-ing jojo ?
- for lambda calculus,
  we have a lattice of type systems.
  how to get a lattice of type systems for jojo ?
  use something like pure type system ?
- how to implement jojo calculus by rewriting ?
- lazy eval will be not needed in language with termination check
  thus for a pie like version of jojo
  we are good
- if we want to implement lazy eval
  we must infer the number of args for each function
  and function's arity must be fixed
  - if we use eager eval
    function's arity and
    the number of return values might be not fixed
* eopl
- [eopl.lang_explicit_refs]
  - block of `let` `do` and last exp
  - unit -- to make every exp have a value
- `assert_eq` for testing
- [eopl.lang_implicit_refs]
- how to implement call-by-name lambda calculus ?
- how to implement call-by-need lambda calculus ?
- eopl about cps
- more examples of eopl programs
* rewriting
* lambda
- what are the lattice of type systems for lambda calculus ?
- can norm-by-eval handle call-by-name terms ?
- what are examples of call-by-value bad terms ?
* de_bruijn
- representing data types
- synth
- theory about equality between lambda terms
  - reflexivity
    symmetry
    transitivity
    congruence
    beta_reduction
    eta_reduction
* curry
- type system of curry style need type variable
  and unification over type variables
* joy
- for simple typed
- how to specify rules ?
  - need to use stack ?
* tartlet
- lazy eval will be not needed in language with termination check
- [note] why we *do need* "type directed norm-by-eval" here ?
- extend tartlet to pie
- the little typer as test
- use `TODO` as un-implemented
- block of let and return
- be sure about the use of TheVal and friends
- test proof: f == (x) => f(x)
- extend tartlet to define new types
  - keep it subrecursive, but be generic about data and ind, rec and iter
- add cumulative (maybe non-cumulative) levels of types -- type_t(n)
* pure
- in addition to a file to eval, also a file of config of sorts, axioms and rules
* miniml
- about type infer
* sysf
* minitt
- [note] why we *do not need* "type directed norm-by-eval" here ?
- [question] I think the use of NormEnv will break `equals`
- add `eqv_t` `same` `replace`
- add constrains to type constructors
- why not jsut use letrec for every definition ? -- learn from EOPL
- add cumulative (maybe non-cumulative) levels of types -- type_t(n)
- be sure about the use of Pattern
  - write some notes
  - Norm do not use Pattern
  - note about how letrec is handled at lookup-time
* module system
- module as value with opaque module_t is not enough -- learn from EOPL
* partech
- ErrMsg and Span
- better report with ErrMsg in context
- [important] fix equals between rules -- how ? by ruleGen with uuid ?
- concrete syntax for rule
  - to use partech as more general tool out side scala
    (like the rosie pattern language)
* compile with cps
* sat
- sat solver vis (how it is vis-ed?)
* complexity
- cook's machine for trans algo to lin-algo
* lambda machine
- new machine for call-by-name or call-by-need lambda
