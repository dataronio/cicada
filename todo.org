* cicada
- Norm
- readback
- string_t
- check undefined during top loading
- pre
  - between any two values, because value can be used as type
  - pre_val and pre_exp should be implemented by pre_norm
  - we will need variance to implement pre
    maybe we do not need to pre-calculet variance
    just compare fields as covariant and function arg as contravariant
  - value of a field must be full value
    val_full_p
    val_part_p
- subtype relation between club and members and class and supers
  - recursively extended to fields in record and pi and si
  - need to compute variance (covariant contravariant invariant) for fields
- partially filled data can be used as type
- cumulative levels of types -- type_t(n)
  - this should be simple since we have subtype relation and infer
- compile to js with runtime type information
  - this means keep Val serde-able
    - Val includes ValFn which contains Exp
      this Exp is also serde-able
- things to leave out in this prototype
  - "do what I mean" function application
    named function application syntax
    and fit the arg in by type when name is not provided
  - I will not even provide named function application syntax for type constructors
  - termination check
* tartlet
- extend tartlet to pie
- the little typer as test
- use `TODO` as un-implemented
- block of let and return
- be sure about the use of TheVal and friends
- test proof: f == (x) => f(x)
- extend tartlet to define new types
  - keep it subrecursive, but be generic about data and ind, rec and iter
- add cumulative (maybe non-cumulative) levels of types -- type_t(n)
* minitt
- [question] I think the use of NormEnv will break `equals`
- add `eqv_t` `same` `replace`
- add constrains to type constructors
- why not jsut use letrec for every definition ? -- learn from EOPL
- add cumulative (maybe non-cumulative) levels of types -- type_t(n)
- be sure about the use of Pattern
  - write some notes
  - Norm do not use Pattern
  - note about how letrec is handled at lookup-time
* module system
- module as value with opaque module_t is not enough -- learn from EOPL
* partech
- ErrMsg and Span
- better report with ErrMsg in context
- [important] fix equals between rules -- how ? by ruleGen with uuid ?
- concrete syntax for rule
  - to use partech as more general tool out side scala
    (like the rosie pattern language)
