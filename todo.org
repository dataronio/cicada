* game semantics
- type as game
- two players: `verifier` and `falsifier`
- object (including function) as winning strategy for `verifier`
- just like a card game
  - `falsifier` owns all the `record_t` game -- logic conjunction
  - `verifier` owns all the `union_t` game -- logic disjunction
  - function type is called `pi_t` (instead of `arrow_t`)
    - in `args` of `pi_t` switch the ownership of cards between `verifier` and `falsifier`
    - in `ret` of `pi_t` the ownership remain the same
- a player's choice is a path to the target position
  - choosing a choice means to resume a paused game
- use normal-play winning rule
  - normal-play is a rule of game,
    which means the first player who used up his/her choices loss the game
* three kinds of expression
- expression
  value (top is constructor)
  normal form (might be neutral)
- game
  top is game constructors: record_t union_t pi_t
  only contain game constructors: record_t union_t pi_t (might be neutral)
- strategy
  strategy with explicit next step
  strategy with every steps (might be neutral)
* cicada/core
- `this_t` and `ref_t` feels not like game
  and they must also occur in strategy
  - just like "three kinds of expression"
    1. value (top is constructor)
    2. neutral (var or eliminator blocked by var)
    3. normal form (might be neutral)
  - we need our rule about `neutral`
- [TO BE SURE] becareful about `game.copy ()`
  since there might be (are there?) circle ref in game
- API of `this_t` in `record_t` and `union_t` map
  use some callback API
  a callback whose arg is the root of current game's map
- how to solve unification problem with side-effect ?
  - constrains:
    - unification only happens when `this` occurs
  - when a `this` occurs (in playing), make a ref to the field,
    and update the field by current partial game
- specify the use of `choices` in `define`
- `record_builder_t` and `union_builder_t` as `game_builder_t`
- `module.game ()` call `game_builder.start ()`
- "prelude.ts" in `std/`
- `module.use ()`
- `game.start ()` -- no `record_t` in `record_t`
  - `record_t` should only be used in `module.define`
- fix `.choices ()`
- step_t for `type-of-type.ts`
- [not yet] term change: use pause and resume instead of ref and deref
- dot.ts -- new type of game, like deep ref_t for record_t
- be sure about winning rule for players
- predicates for `game_t`, such as `end_p` `loss_p` `win_p` -- for better tests
* cicadascript
- more examples from /old
- semantics of game plays
- example games about `nat_t` and `list_t` -- cicada/simple
- example games about `vect_t` -- cicada/core
- game semantics for the type system
- compile to js with runtime type information
  - { type: { field: <type> }, field: <value> }
- syntax and semantics which is higher order module ?
  - one syntax can be implemented by many semantics
  - one design of semantics can be used by many syntaxes
- reuse js syntax
  the syntax of js is almost enough
  we only need to do the following extensions
  - function call with named field
    `<f> (<field> = <object>)`
  - auto currying
    `f (a) (b)` == `f (a, b)`
  - no `,` in function call
    - maybe we need to limit the use of infix notation
    - maybe use newline as `,`
* syntax
- concentrate on semantics first
- renew parsing-tech and cicada-rs
- scanner/
- parsing-tech/
* the way to cicada language
- do not start from a "well designed" type theory
- start from the way I want to do formalize
- implement it and fix it by examples
- form a type theory at the end
