- value.toString -- for testing

- exe for Fn
  - [maybe] Fn not only need env, but also need bind
- case class Bind
- case class Id
- check
- what is the difference between set, type and cat ?
  - set: ==, member relation, subset relation
  - type: ==, member relation
  - cat: ==, |
------
- learn from the design of collection of scala
- nat
- bool
- list
- lattices
  - eval of a exp to value
  - values are lattices, serves as denotational semantics of the language
- to remember cicada-rs' way of type logic programming
- how to handle `this` ?
  - learn from DOT
  - try to use bindingMap and unification to handle `this`
* fulfill
- no type, just value
  partly fulfilled value as type
  and fulfilling relation between values
  - union, record, pi are simple
  - closure need special treatment
    might require NbE
  - fulfilling relation for neutral value will be hard to handle
    just like we need NbE
    to handle equivalence relation for neutral value in pie
    - we might use something like NbE
      or design our own ways
    - but when will neutral value occur?
      only on apply ?
      not on `.field` ?
- `x: type` is special
- Exp
  Constructor -- Value
  Eliminator  -- Neutral
- value v.s. full value
  - value without union and x: type
- nominal subtype relation
  instead of structural subtype relation
  - thus we do not need structural type union and intersection
* game as type class
- we can implement game as type class
  and view other type as game later
- thus we can do not think about game semantics,
  only to implement the fulfill type system first
* learn from scala macro system -- for AST design
* three kinds of expression
- expression
  value (top is constructor)
  normal form (might be neutral)
- game
  top is game constructors: record_t union_t pi_t
  only contain game constructors: record_t union_t pi_t (might be neutral)
- strategy
  strategy with explicit next step
  strategy with every steps (might be neutral)
* cicada/core
- `this_t` and `ref_t` feels not like game
  and they must also occur in strategy
  - just like "three kinds of expression"
    1. value (top is constructor)
    2. neutral (var or eliminator blocked by var)
    3. normal form (might be neutral)
  - we need our rule about `neutral`
- [TO BE SURE] becareful about `game.copy ()`
  since there might be (are there?) circle ref in game
- API of `this_t` in `record_t` and `union_t` map
  use some callback API
  a callback whose arg is the root of current game's map
- how to solve unification problem with side-effect ?
  - constrains:
    - unification only happens when `this` occurs
  - when a `this` occurs (in playing), make a ref to the field,
    and update the field by current partial game
- specify the use of `choices` in `define`
- `record_builder_t` and `union_builder_t` as `game_builder_t`
- `module.game ()` call `game_builder.start ()`
- "prelude.ts" in `std/`
- `module.use ()`
- `game.start ()` -- no `record_t` in `record_t`
  - `record_t` should only be used in `module.define`
- fix `.choices ()`
- step_t for `type-of-type.ts`
- [not yet] term change: use pause and resume instead of ref and deref
- dot.ts -- new type of game, like deep ref_t for record_t
- be sure about winning rule for players
- predicates for `game_t`, such as `end_p` `loss_p` `win_p` -- for better tests
* cicada
- more examples from /old
- semantics of game plays
- example games about `nat_t` and `list_t` -- cicada/simple
- example games about `vect_t` -- cicada/core
- game semantics for the type system
- compile to js with runtime type information
  - { type: { field: <type> }, field: <value> }
- syntax and semantics which is higher order module ?
  - one syntax can be implemented by many semantics
  - one design of semantics can be used by many syntaxes
- reuse js syntax
  the syntax of js is almost enough
  we only need to do the following extensions
  - function call with named field
    `<f> (<field> = <object>)`
  - auto currying
    `f (a) (b)` == `f (a, b)`
  - no `,` in function call
    - maybe we need to limit the use of infix notation
    - maybe use newline as `,`
* syntax
- concentrate on semantics first
- renew parsing-tech and cicada-rs
- scanner/
- parsing-tech/
* [note] game semantics
- type as game
- two players: `Verifier` and `Falsifier`
- object (including function) as winning strategy for `Verifier`
- just like a card game
  - `Falsifier` owns all the `Record` game -- logic conjunction
  - `Verifier` owns all the `Union` game -- logic disjunction
  - function type is called `Pi` (instead of `arrow_t`)
    - in `args` of `Pi` switch the ownership of cards between `Verifier` and `Falsifier`
    - in `ret` of `Pi` the ownership remain the same
- a player's choice is a path to the target position
  - choosing a choice means to resume a paused game
- use normal-play winning rule
  - normal-play is a rule of game,
    which means the first player who used up his/her choices loss the game
- no draw
- the order of play is not strict
  - sometimes we can swap the order of local plays
- different choices have different effect -- monomorphism
- different players have different choices
  - in a specific game, a choice belong to a player,
    given a choice, we know which player is playing the choice.
